#!/usr/bin/env python3
"""
Frame.io Production Upload Manager
Gestionnaire d'upload de production int√©grant ngrok et cr√©ation de dossiers
"""

import asyncio
import logging
import subprocess
import time
import requests
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any

from .auth import FrameIOAuth
from .structure import FrameIOStructureManager
from .upload import FrameIOUploadManager
from .public_server import PublicFileServer
from ..discord import DiscordNotifier

logger = logging.getLogger(__name__)


class NgrokTunnelManager:
    """Gestionnaire de tunnel ngrok pour la production"""
    
    def __init__(self, port: int):
        self.port = port
        self.process = None
        self.public_url = None
        
    async def start(self) -> bool:
        """D√©marre le tunnel ngrok"""
        try:
            # V√©rifier ngrok
            result = subprocess.run(['which', 'ngrok'], capture_output=True, text=True)
            if result.returncode != 0:
                logger.error("‚ùå ngrok non install√©")
                return False
            
            # V√©rifier auth ngrok
            auth_check = subprocess.run(['ngrok', 'config', 'check'], capture_output=True, text=True)
            if auth_check.returncode != 0:
                logger.error("‚ùå ngrok non configur√©")
                return False
            
            # D√©marrer ngrok
            logger.info(f"üöÄ D√©marrage tunnel ngrok sur port {self.port}")
            self.process = subprocess.Popen(
                ['ngrok', 'http', str(self.port)],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            # Attendre et r√©cup√©rer l'URL
            await asyncio.sleep(5)
            
            for attempt in range(10):
                try:
                    response = requests.get('http://localhost:4040/api/tunnels', timeout=10)
                    if response.status_code == 200:
                        tunnels = response.json()
                        for tunnel in tunnels.get('tunnels', []):
                            if tunnel.get('proto') == 'https':
                                self.public_url = tunnel['public_url']
                                logger.info(f"‚úÖ Tunnel ngrok actif: {self.public_url}")
                                return True
                    
                    await asyncio.sleep(2)
                except Exception as e:
                    if attempt == 9:
                        logger.error(f"‚ùå Erreur ngrok apr√®s {attempt + 1} tentatives: {e}")
                        return False
                    await asyncio.sleep(2)
            
            logger.error("‚ùå Impossible de r√©cup√©rer l'URL ngrok")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Erreur d√©marrage ngrok: {e}")
            return False
    
    def stop(self):
        """Arr√™te le tunnel ngrok"""
        if self.process:
            self.process.terminate()
            self.process.wait()
            logger.info("üõë Tunnel ngrok arr√™t√©")


class FrameIOProductionUploader:
    """Gestionnaire d'upload de production pour Frame.io"""
    
    def __init__(self, auth: FrameIOAuth, discord_webhook_url: Optional[str] = None):
        self.auth = auth
        self.structure_manager = FrameIOStructureManager(auth)
        self.upload_manager = FrameIOUploadManager(auth)
        self.discord_notifier = DiscordNotifier(discord_webhook_url) if discord_webhook_url else None
        
        # Serveur HTTP et ngrok
        self.http_server: Optional[PublicFileServer] = None
        self.ngrok_manager: Optional[NgrokTunnelManager] = None
        
        logger.info("üì§ FrameIOProductionUploader initialis√©")
    
    async def upload_file_with_structure(
        self, 
        file_path: Path, 
        project_name: str = "UNDLM_DOCU",
        scene_name: Optional[str] = None,
        shot_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Upload un fichier avec cr√©ation automatique de la structure de dossiers
        
        Args:
            file_path: Chemin vers le fichier √† uploader
            project_name: Nom du projet Frame.io
            scene_name: Nom de la sc√®ne (optionnel, auto-d√©tect√© si None)
            shot_name: Nom du shot (optionnel, auto-d√©tect√© si None)
            
        Returns:
            Dict contenant les informations du r√©sultat
        """
        result = {
            'success': False,
            'file_id': None,
            'folder_id': None,
            'project_id': None,
            'view_url': None,
            'error': None
        }
        
        try:
            logger.info(f"üì§ D√©but upload production: {file_path.name}")
            
            # 1. V√©rifier le fichier
            if not file_path.exists():
                raise FileNotFoundError(f"Fichier non trouv√©: {file_path}")
            
            logger.info(f"üìÅ Fichier: {file_path} ({file_path.stat().st_size} bytes)")
            
            # 2. R√©cup√©rer le projet
            projects = await self.structure_manager.get_projects()
            target_project = None
            
            for project in projects:
                if project.name == project_name:
                    target_project = project
                    break
            
            if not target_project:
                raise ValueError(f"Projet '{project_name}' non trouv√©")
            
            logger.info(f"‚úÖ Projet trouv√©: {target_project.name}")
            result['project_id'] = target_project.id
            
            # 3. D√©terminer la structure de dossiers
            if not scene_name or not shot_name:
                # Auto-d√©tection depuis le nom de fichier (TODO: int√©grer nomenclature)
                scene_name = scene_name or "PRODUCTION"
                shot_name = shot_name or file_path.stem
            
            logger.info(f"üìÇ Structure: {scene_name} > {shot_name}")
            
            # 4. Cr√©er la structure de dossiers
            try:
                folder_id = await self.structure_manager.get_or_create_folder_path(
                    scene_name,
                    shot_name,
                    target_project.id
                )
                
                if not folder_id:
                    # Fallback sur le root folder
                    logger.warning("‚ö†Ô∏è Cr√©ation dossier √©chou√©e, utilisation root folder")
                    folder_id = target_project.root_folder_id
                
                logger.info(f"‚úÖ Dossier de destination: {folder_id}")
                result['folder_id'] = folder_id
                
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erreur cr√©ation structure: {e}")
                logger.info("üìÇ Utilisation du root folder")
                folder_id = target_project.root_folder_id
                result['folder_id'] = folder_id
            
            # 5. Pr√©parer le serveur HTTP et ngrok
            logger.info("üåê Pr√©paration serveur HTTP et ngrok...")
            
            # D√©marrer serveur HTTP
            self.http_server = PublicFileServer(host="127.0.0.1", port=0)
            if not self.http_server.start():
                raise RuntimeError("Impossible de d√©marrer le serveur HTTP")
            
            # Exposer le fichier
            local_url = self.http_server.add_file(str(file_path))
            if not local_url:
                raise RuntimeError("Impossible d'exposer le fichier")
            
            logger.info(f"üìÇ Fichier expos√©: {local_url}")
            
            # D√©marrer ngrok
            self.ngrok_manager = NgrokTunnelManager(self.http_server.actual_port)
            if not await self.ngrok_manager.start():
                raise RuntimeError("Impossible de d√©marrer ngrok")
            
            # Construire URL publique
            file_name = local_url.split('/')[-1]
            public_url = f"{self.ngrok_manager.public_url}/{file_name}"
            logger.info(f"üåç URL publique: {public_url}")
            
            # V√©rifier accessibilit√©
            response = requests.head(public_url, timeout=10)
            if response.status_code != 200:
                raise RuntimeError(f"URL publique non accessible: {response.status_code}")
            
            logger.info("‚úÖ URL publique v√©rifi√©e")
            
            # 6. Upload vers Frame.io
            logger.info("üì§ Upload vers Frame.io...")
            
            frameio_file = await self.upload_manager._create_file_remote_upload(
                str(file_path),
                folder_id,
                public_url
            )
            
            if not frameio_file:
                raise RuntimeError("Upload Frame.io √©chou√©")
            
            logger.info(f"‚úÖ Upload r√©ussi: {frameio_file.name} (ID: {frameio_file.id})")
            
            result['success'] = True
            result['file_id'] = frameio_file.id
            
            # Construire l'URL de visualisation Frame.io
            result['view_url'] = f"https://app.frame.io/project/{target_project.id}/asset/{frameio_file.id}"
            
            # 7. Notification Discord
            if self.discord_notifier:
                try:
                    await self._send_discord_notification(
                        file_path,
                        frameio_file,
                        target_project,
                        result['view_url']
                    )
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Erreur notification Discord: {e}")
            
            # 8. Attendre le traitement Frame.io
            logger.info("‚è≥ Attente traitement Frame.io...")
            await asyncio.sleep(10)
            
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Erreur upload production: {e}")
            result['error'] = str(e)
            return result
        
        finally:
            # Nettoyage
            await self._cleanup()
    
    async def _send_discord_notification(
        self, 
        file_path: Path, 
        frameio_file, 
        project, 
        view_url: str
    ):
        """Envoie une notification Discord"""
        embed = {
            "title": "üì§ Nouveau fichier upload√© sur Frame.io",
            "color": 0x00ff00,
            "fields": [
                {"name": "üìÅ Fichier", "value": file_path.name, "inline": True},
                {"name": "üé¨ Projet", "value": project.name, "inline": True},
                {"name": "üÜî File ID", "value": frameio_file.id, "inline": False},
                {"name": "üîó Voir sur Frame.io", "value": f"[Ouvrir]({view_url})", "inline": False}
            ],
            "timestamp": datetime.utcnow().isoformat(),
            "footer": {"text": "RL PostFlow Pipeline"}
        }
        
        await self.discord_notifier.send_embed(embed)
    
    async def _cleanup(self):
        """Nettoyage des ressources"""
        if self.ngrok_manager:
            self.ngrok_manager.stop()
            self.ngrok_manager = None
        
        if self.http_server:
            self.http_server.stop()
            self.http_server = None
        
        logger.info("üßπ Nettoyage termin√©")


# Fonction utilitaire pour l'int√©gration dans le pipeline principal
async def upload_file_to_frameio(
    file_path: Path,
    auth: FrameIOAuth,
    discord_webhook_url: Optional[str] = None,
    project_name: str = "UNDLM_DOCU"
) -> Dict[str, Any]:
    """
    Fonction utilitaire pour upload rapide depuis le pipeline principal
    """
    uploader = FrameIOProductionUploader(auth, discord_webhook_url)
    return await uploader.upload_file_with_structure(file_path, project_name)
