#!/usr/bin/env python3
"""
üîó Auto Hooks - Syst√®me de hooks automatiques
=============================================

Hooks automatiques pour Google Sheets, Discord et autres int√©grations.
S'abonne aux √©v√©nements et g√®re les mises √† jour automatiquement.

Version: 4.1.5
Date: 31 juillet 2025
"""

import asyncio
import logging
from typing import Dict, Any, Optional
from datetime import datetime

from src.utils.event_manager import event_manager, EventType, Event

logger = logging.getLogger(__name__)


class GoogleSheetsHook:
    """Hook automatique pour Google Sheets"""
    
    def __init__(self, sheets_tracker=None):
        self.sheets_tracker = sheets_tracker
        self.enabled = sheets_tracker is not None
        
        if self.enabled:
            # S'abonner aux √©v√©nements pertinents
            event_manager.subscribe(EventType.STATUS_CHANGED, self.on_status_changed, priority=10)
            event_manager.subscribe(EventType.UPLOAD_COMPLETED, self.on_upload_completed, priority=10)
            event_manager.subscribe(EventType.FRAMEIO_COMMENT_RECEIVED, self.on_frameio_comment, priority=10)
            event_manager.subscribe(EventType.REVIEW_STATUS_CHANGED, self.on_review_status_changed, priority=10)
            
            logger.info("‚úÖ Google Sheets Hook activ√©")
        else:
            logger.warning("‚ö†Ô∏è Google Sheets Hook d√©sactiv√© (pas de tracker)")
    
    async def on_status_changed(self, event: Event):
        """R√©agit aux changements de statut"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            shot_name = data.get('shot_name')
            status = data.get('status')
            frameio_link = data.get('frameio_link')
            comment = data.get('comment')
            
            if shot_name and status:
                logger.info(f"üìä [Sheets Hook] Mise √† jour statut: {shot_name} -> {status}")
                
                if hasattr(self.sheets_tracker, 'update_shot_status'):
                    await self.sheets_tracker.update_shot_status(
                        nomenclature=shot_name,  # Utiliser nomenclature au lieu de shot_id
                        status=status,
                        additional_data={
                            'frameio_link': frameio_link,
                            'comment': comment
                        }
                    )
                else:
                    logger.warning("‚ö†Ô∏è sheets_tracker.update_shot_status non disponible")
                    
        except Exception as e:
            logger.error(f"‚ùå [Sheets Hook] Erreur mise √† jour statut: {e}")
    
    async def on_upload_completed(self, event: Event):
        """R√©agit aux uploads termin√©s"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            shot_name = data.get('shot_name')
            frameio_link = data.get('frameio_link')
            thumbnail_url = data.get('thumbnail_url')
            
            if shot_name:
                logger.info(f"üìä [Sheets Hook] Upload termin√©: {shot_name}")
                
                # Mettre √† jour avec les liens
                if hasattr(self.sheets_tracker, 'update_shot_status'):
                    await self.sheets_tracker.update_shot_status(
                        nomenclature=shot_name,  # Utiliser nomenclature au lieu de shot_id
                        status="UPLOADED",
                        additional_data={
                            'frameio_link': frameio_link,
                            'thumbnail_url': thumbnail_url
                        }
                    )
                    
        except Exception as e:
            logger.error(f"‚ùå [Sheets Hook] Erreur upload termin√©: {e}")
    
    async def on_frameio_comment(self, event: Event):
        """R√©agit aux commentaires Frame.io avec logique intelligente"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            shot_name = data.get('shot_name')
            comment_text = data.get('comment_text')
            review_status = data.get('review_status')
            
            if shot_name and comment_text:
                logger.info(f"üìä [Sheets Hook] Commentaire Frame.io: {shot_name}")
                
                # Logique intelligente pour d√©terminer le statut selon les commentaires
                intelligent_status = self._analyze_comment_status(comment_text, review_status)
                
                # Mettre √† jour avec le commentaire et le statut intelligent
                if hasattr(self.sheets_tracker, 'update_shot_status'):
                    await self.sheets_tracker.update_shot_status(
                        nomenclature=shot_name,
                        status=intelligent_status,
                        additional_data={
                            'comment': comment_text,
                            'original_status': review_status
                        }
                    )
                    
        except Exception as e:
            logger.error(f"‚ùå [Sheets Hook] Erreur commentaire Frame.io: {e}")
    
    def _analyze_comment_status(self, comment_text: str, review_status: str = None) -> str:
        """
        Analyse intelligente du statut bas√©e sur les commentaires
        
        Logique:
        - Pas de commentaire ‚Üí NEED_REVIEW
        - Premier commentaire simple ‚Üí APPROVED  
        - Commentaires suppl√©mentaires ‚Üí NEED_REWORK
        """
        if not comment_text or comment_text.strip() == "":
            return "NEED_REVIEW"
        
        # Mots cl√©s positifs (validation)
        positive_keywords = [
            'ok', 'valid√©', 'parfait', 'excellent', 'bien', 'good', 'approved', 'approve',
            'valide', 'nickel', 'super', 'bravo', 'top', '√ßa marche', 'c\'est bon',
            'validated', 'accepted', 'great', 'perfect'
        ]
        
        # Mots cl√©s n√©gatifs (modifications n√©cessaires)
        negative_keywords = [
            'modif', 'modification', 'change', 'corriger', 'correction', 'probl√®me', 
            'problem', 'issue', 'fix', 'revoir', 'refaire', '√† retravailler',
            'pas bon', 'incorrect', 'erreur', 'error', 'wrong', 'redo', 'revise'
        ]
        
        comment_lower = comment_text.lower()
        
        # V√©rifier les mots cl√©s n√©gatifs en premier (priorit√©) - recherche par mots entiers
        has_negative = any(f' {keyword} ' in f' {comment_lower} ' or 
                          comment_lower.startswith(f'{keyword} ') or 
                          comment_lower.endswith(f' {keyword}') or 
                          comment_lower == keyword 
                          for keyword in negative_keywords)
        if has_negative:
            logger.info(f"üîÑ [Sheets Hook] Commentaire n√©gatif d√©tect√©: NEED_REWORK")
            return "NEED_REWORK"
        
        # V√©rifier les mots cl√©s positifs - recherche par mots entiers
        has_positive = any(f' {keyword} ' in f' {comment_lower} ' or 
                          comment_lower.startswith(f'{keyword} ') or 
                          comment_lower.endswith(f' {keyword}') or 
                          comment_lower == keyword 
                          for keyword in positive_keywords)
        if has_positive:
            logger.info(f"‚úÖ [Sheets Hook] Commentaire positif d√©tect√©: APPROVED")
            return "APPROVED"
        
        # Commentaire neutre/long = besoin de review suppl√©mentaire
        logger.info(f"‚è≥ [Sheets Hook] Commentaire neutre d√©tect√©: NEED_REVIEW")
        return "NEED_REVIEW"
    
    async def on_review_status_changed(self, event: Event):
        """R√©agit aux changements de statut de review"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            shot_name = data.get('shot_name')
            review_status = data.get('review_status')
            comment = data.get('comment')
            
            if shot_name and review_status:
                logger.info(f"üìä [Sheets Hook] Statut review: {shot_name} -> {review_status}")
                
                if hasattr(self.sheets_tracker, 'update_shot_status'):
                    await self.sheets_tracker.update_shot_status(
                        nomenclature=shot_name,  # Utiliser nomenclature au lieu de shot_id
                        status=review_status,
                        additional_data={
                            'comment': comment
                        }
                    )
                    
        except Exception as e:
            logger.error(f"‚ùå [Sheets Hook] Erreur statut review: {e}")


class DiscordHook:
    """Hook automatique pour Discord"""
    
    def __init__(self, discord_notifier=None, user_notifier=None):
        self.discord_notifier = discord_notifier
        self.user_notifier = user_notifier
        self.enabled = discord_notifier is not None or user_notifier is not None
        
        if self.enabled:
            # S'abonner aux √©v√©nements pertinents
            event_manager.subscribe(EventType.FILE_PROCESSING_COMPLETED, self.on_file_processed, priority=5)
            event_manager.subscribe(EventType.FILE_PROCESSING_FAILED, self.on_file_failed, priority=5)
            event_manager.subscribe(EventType.FRAMEIO_COMMENT_RECEIVED, self.on_frameio_comment, priority=5)
            event_manager.subscribe(EventType.REVIEW_STATUS_CHANGED, self.on_review_status_changed, priority=5)
            event_manager.subscribe(EventType.PIPELINE_STARTED, self.on_pipeline_started, priority=5)
            event_manager.subscribe(EventType.PIPELINE_STOPPED, self.on_pipeline_stopped, priority=5)
            event_manager.subscribe(EventType.ERROR_OCCURRED, self.on_error, priority=5)
            
            logger.info("‚úÖ Discord Hook activ√©")
        else:
            logger.warning("‚ö†Ô∏è Discord Hook d√©sactiv√© (pas de notifier)")
    
    async def on_file_processed(self, event: Event):
        """Notifie quand un fichier est trait√©"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            file_name = data.get('file_name', 'Fichier inconnu')
            frameio_link = data.get('frameio_link')
            thumbnail_url = data.get('thumbnail_url')
            shot_name = data.get('shot_name')
            
            logger.info(f"üé¨ [Discord Hook] Fichier trait√©: {file_name}")
            
            # Utiliser user_notifier en priorit√©
            notifier = self.user_notifier or self.discord_notifier
            
            if self.user_notifier and hasattr(self.user_notifier, 'notify_file_processed'):
                # Notification avec mention utilisateur si possible
                from pathlib import Path
                await self.user_notifier.notify_file_processed(
                    file_path=Path(file_name),
                    frameio_link=frameio_link,
                    thumbnail_url=thumbnail_url
                )
            elif self.discord_notifier:
                # Notification standard
                message = f"üé¨ Fichier trait√©: {file_name}"
                if frameio_link:
                    message += f"\nüîó Frame.io: {frameio_link}"
                
                if hasattr(self.discord_notifier, 'notify_file_processed'):
                    self.discord_notifier.notify_file_processed(
                        file_name, message, frameio_link, thumbnail_url
                    )
                else:
                    self.discord_notifier.notify_system_status("Fichier trait√©", message)
                    
        except Exception as e:
            logger.error(f"‚ùå [Discord Hook] Erreur notification fichier trait√©: {e}")
    
    async def on_file_failed(self, event: Event):
        """Notifie quand un fichier √©choue"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            file_name = data.get('file_name', 'Fichier inconnu')
            error = data.get('error', 'Erreur inconnue')
            
            logger.info(f"‚ùå [Discord Hook] Fichier √©chou√©: {file_name}")
            
            notifier = self.user_notifier or self.discord_notifier
            
            message = f"‚ùå √âchec traitement: {file_name}\nüîç Erreur: {error}"
            
            if self.user_notifier and hasattr(self.user_notifier, 'send_system_notification'):
                await self.user_notifier.send_system_notification("Erreur de traitement", message)
            elif self.discord_notifier:
                self.discord_notifier.notify_system_status("Erreur de traitement", message)
                
        except Exception as e:
            logger.error(f"‚ùå [Discord Hook] Erreur notification √©chec: {e}")
    
    async def on_frameio_comment(self, event: Event):
        """Notifie les commentaires Frame.io avec analyse intelligente"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            shot_name = data.get('shot_name')
            comment_text = data.get('comment_text')
            review_status = data.get('review_status')
            commenter = data.get('commenter', 'Utilisateur')
            
            logger.info(f"üí¨ [Discord Hook] Commentaire Frame.io: {shot_name}")
            
            # Analyse intelligente du statut
            intelligent_status = self._analyze_comment_for_discord(comment_text, review_status)
            
            notifier = self.user_notifier or self.discord_notifier
            
            # √âmoji selon le statut intelligent
            status_emoji = {
                'APPROVED': '‚úÖ',
                'NEED_REWORK': 'üîÑ', 
                'NEED_REVIEW': '‚è≥',
                'REJECTED': '‚ùå'
            }.get(intelligent_status, 'üí¨')
            
            status_text = {
                'APPROVED': 'Valid√©',
                'NEED_REWORK': 'Modifications requises',
                'NEED_REVIEW': 'En attente de review',
                'REJECTED': 'Rejet√©'
            }.get(intelligent_status, 'Review')
            
            message = f"{status_emoji} **{shot_name}** - {status_text}\n"
            message += f"üë§ **{commenter}**\n"
            message += f"üí¨ {comment_text[:200]}{'...' if len(comment_text) > 200 else ''}\n"
            message += f"ü§ñ Statut auto-d√©tect√©: **{intelligent_status}**"
            
            if self.user_notifier and hasattr(self.user_notifier, 'send_system_notification'):
                await self.user_notifier.send_system_notification("Commentaire Frame.io", message)
            elif self.discord_notifier:
                self.discord_notifier.notify_system_status("Commentaire Frame.io", message)
                
        except Exception as e:
            logger.error(f"‚ùå [Discord Hook] Erreur notification commentaire: {e}")
    
    def _analyze_comment_for_discord(self, comment_text: str, review_status: str = None) -> str:
        """Analyse rapide pour Discord (m√™me logique que Google Sheets)"""
        if not comment_text or comment_text.strip() == "":
            return "NEED_REVIEW"
        
        positive_keywords = ['ok', 'valid√©', 'parfait', 'excellent', 'bien', 'good', 'approved', 'approve', 'valide', 'nickel', 'super', 'bravo', 'top']
        negative_keywords = ['modif', 'modification', 'change', 'corriger', 'correction', 'probl√®me', 'problem', 'issue', 'fix', 'revoir', 'refaire']
        
        comment_lower = comment_text.lower()
        
        # V√©rifier les mots cl√©s n√©gatifs en premier (priorit√©) - recherche par mots entiers
        has_negative = any(f' {keyword} ' in f' {comment_lower} ' or 
                          comment_lower.startswith(f'{keyword} ') or 
                          comment_lower.endswith(f' {keyword}') or 
                          comment_lower == keyword 
                          for keyword in negative_keywords)
        if has_negative:
            return "NEED_REWORK"
            
        # V√©rifier les mots cl√©s positifs - recherche par mots entiers  
        has_positive = any(f' {keyword} ' in f' {comment_lower} ' or 
                          comment_lower.startswith(f'{keyword} ') or 
                          comment_lower.endswith(f' {keyword}') or 
                          comment_lower == keyword 
                          for keyword in positive_keywords)
        if has_positive:
            return "APPROVED" 
        else:
            return "NEED_REVIEW"
    
    async def on_review_status_changed(self, event: Event):
        """Notifie les changements de statut de review"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            shot_name = data.get('shot_name')
            review_status = data.get('review_status')
            old_status = data.get('old_status')
            
            if review_status == old_status:
                return  # Pas de changement
            
            logger.info(f"üîÑ [Discord Hook] Statut review: {shot_name} -> {review_status}")
            
            # √âmoji selon le nouveau statut
            status_emoji = {
                'APPROVED': '‚úÖ',
                'REJECTED': '‚ùå',
                'NEED_REWORK': 'üîÑ',
                'PENDING': '‚è≥'
            }.get(review_status, 'üìù')
            
            status_text = {
                'APPROVED': 'Approuv√©',
                'REJECTED': 'Rejet√©',
                'NEED_REWORK': 'Retravail demand√©',
                'PENDING': 'En attente'
            }.get(review_status, review_status)
            
            message = f"{status_emoji} **{shot_name}** - {status_text}"
            if old_status:
                message += f"\nüîÑ Changement: {old_status} ‚Üí {review_status}"
            
            notifier = self.user_notifier or self.discord_notifier
            
            if self.user_notifier and hasattr(self.user_notifier, 'send_system_notification'):
                await self.user_notifier.send_system_notification("Statut Review", message)
            elif self.discord_notifier:
                self.discord_notifier.notify_system_status("Statut Review", message)
                
        except Exception as e:
            logger.error(f"‚ùå [Discord Hook] Erreur notification statut review: {e}")
    
    async def on_pipeline_started(self, event: Event):
        """Notifie le d√©marrage du pipeline"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            version = data.get('version', 'Unknown')
            
            message = f"üöÄ PostFlow v{version} d√©marr√©\nLe pipeline de traitement est maintenant actif"
            
            notifier = self.user_notifier or self.discord_notifier
            
            if self.user_notifier and hasattr(self.user_notifier, 'send_system_notification'):
                await self.user_notifier.send_system_notification("Pipeline d√©marr√©", message)
            elif self.discord_notifier:
                self.discord_notifier.notify_system_status("Pipeline d√©marr√©", message)
                
        except Exception as e:
            logger.error(f"‚ùå [Discord Hook] Erreur notification d√©marrage: {e}")
    
    async def on_pipeline_stopped(self, event: Event):
        """Notifie l'arr√™t du pipeline"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            version = data.get('version', 'Unknown')
            
            message = f"üõë PostFlow v{version} arr√™t√©\nLe pipeline de traitement a √©t√© arr√™t√©"
            
            notifier = self.user_notifier or self.discord_notifier
            
            if self.user_notifier and hasattr(self.user_notifier, 'send_system_notification'):
                await self.user_notifier.send_system_notification("Pipeline arr√™t√©", message)
            elif self.discord_notifier:
                self.discord_notifier.notify_system_status("Pipeline arr√™t√©", message)
                
        except Exception as e:
            logger.error(f"‚ùå [Discord Hook] Erreur notification arr√™t: {e}")
    
    async def on_error(self, event: Event):
        """Notifie les erreurs importantes"""
        if not self.enabled:
            return
        
        try:
            data = event.data
            error_message = data.get('error', 'Erreur inconnue')
            component = data.get('component', 'Syst√®me')
            
            message = f"‚ö†Ô∏è Erreur {component}\nüîç {error_message}"
            
            notifier = self.user_notifier or self.discord_notifier
            
            if self.user_notifier and hasattr(self.user_notifier, 'send_system_notification'):
                await self.user_notifier.send_system_notification("Erreur syst√®me", message)
            elif self.discord_notifier:
                self.discord_notifier.notify_system_status("Erreur syst√®me", message)
                
        except Exception as e:
            logger.error(f"‚ùå [Discord Hook] Erreur notification erreur: {e}")


class AutoHooksManager:
    """Gestionnaire des hooks automatiques"""
    
    def __init__(self):
        self.hooks = []
        self.initialized = False
    
    def initialize(self, sheets_tracker=None, discord_notifier=None, user_notifier=None):
        """Initialise tous les hooks automatiques"""
        if self.initialized:
            logger.warning("‚ö†Ô∏è Hooks d√©j√† initialis√©s")
            return
        
        # Hook Google Sheets
        if sheets_tracker:
            sheets_hook = GoogleSheetsHook(sheets_tracker)
            self.hooks.append(sheets_hook)
        
        # Hook Discord
        if discord_notifier or user_notifier:
            discord_hook = DiscordHook(discord_notifier, user_notifier)
            self.hooks.append(discord_hook)
        
        self.initialized = True
        logger.info(f"üîó Auto Hooks initialis√©s: {len(self.hooks)} hooks actifs")
    
    def get_stats(self) -> Dict[str, Any]:
        """Retourne les statistiques des hooks"""
        return {
            'hooks_count': len(self.hooks),
            'initialized': self.initialized,
            'event_manager_stats': event_manager.get_stats()
        }


# Instance globale
auto_hooks = AutoHooksManager()
